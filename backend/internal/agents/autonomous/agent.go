// Package autonomous provides an AI-powered autonomous agent system for APEX.BUILD
// This is CRITICAL Replit parity - the autonomous agent that builds, tests, and deploys
// applications from natural language descriptions without human intervention.
package autonomous

import (
	"context"
	"fmt"
	"log"
	"sync"
	"time"

	"github.com/google/uuid"
)

// AgentState represents the current state of the autonomous agent
type AgentState string

const (
	StateIdle       AgentState = "idle"       // Agent is ready for a new task
	StatePlanning   AgentState = "planning"   // Agent is decomposing the task
	StateExecuting  AgentState = "executing"  // Agent is executing actions
	StateValidating AgentState = "validating" // Agent is validating output
	StatePaused     AgentState = "paused"     // Agent is paused by user
	StateCompleted  AgentState = "completed"  // Task completed successfully
	StateFailed     AgentState = "failed"     // Task failed after all retries
	StateCancelled  AgentState = "cancelled"  // Task was cancelled by user
)

// ActionType defines the kinds of actions the agent can perform
type ActionType string

const (
	ActionCreateFile   ActionType = "create_file"   // Create a new file
	ActionModifyFile   ActionType = "modify_file"   // Modify existing file
	ActionDeleteFile   ActionType = "delete_file"   // Delete a file
	ActionRunCommand   ActionType = "run_command"   // Run terminal command
	ActionRunTests     ActionType = "run_tests"     // Execute tests
	ActionInstallDeps  ActionType = "install_deps"  // Install dependencies
	ActionAIGenerate   ActionType = "ai_generate"   // Call AI for generation
	ActionAIAnalyze    ActionType = "ai_analyze"    // Call AI for analysis
	ActionValidate     ActionType = "validate"      // Validate output
	ActionDeploy       ActionType = "deploy"        // Deploy application
	ActionRollback     ActionType = "rollback"      // Rollback changes
)

// AutonomousTask represents a task for the autonomous agent
type AutonomousTask struct {
	ID          string                 `json:"id"`
	UserID      uint                   `json:"user_id"`
	ProjectID   *uint                  `json:"project_id,omitempty"`
	Description string                 `json:"description"` // Natural language description
	State       AgentState             `json:"state"`
	Plan        *ExecutionPlan         `json:"plan,omitempty"`
	Progress    int                    `json:"progress"` // 0-100
	Logs        []LogEntry             `json:"logs"`
	Actions     []*ExecutedAction      `json:"actions"`
	Artifacts   []Artifact             `json:"artifacts"`
	Error       string                 `json:"error,omitempty"`
	Metadata    map[string]interface{} `json:"metadata,omitempty"`
	CreatedAt   time.Time              `json:"created_at"`
	StartedAt   *time.Time             `json:"started_at,omitempty"`
	CompletedAt *time.Time             `json:"completed_at,omitempty"`
	RetryCount  int                    `json:"retry_count"`
	MaxRetries  int                    `json:"max_retries"`

	mu sync.RWMutex
}

// ExecutionPlan is the structured plan generated by the planner
type ExecutionPlan struct {
	ID           string       `json:"id"`
	TaskID       string       `json:"task_id"`
	Steps        []*PlanStep  `json:"steps"`
	TechStack    *TechStack   `json:"tech_stack,omitempty"`
	EstimatedTime time.Duration `json:"estimated_time"`
	Dependencies []string     `json:"dependencies,omitempty"`
	CreatedAt    time.Time    `json:"created_at"`
}

// TechStack defines the technologies to use
type TechStack struct {
	Frontend string   `json:"frontend,omitempty"` // React, Vue, Next.js
	Backend  string   `json:"backend,omitempty"`  // Node, Go, Python
	Database string   `json:"database,omitempty"` // PostgreSQL, MongoDB
	Styling  string   `json:"styling,omitempty"`  // Tailwind, CSS Modules
	Extras   []string `json:"extras,omitempty"`   // Additional libraries
}

// PlanStep represents a single step in the execution plan
type PlanStep struct {
	ID           string                 `json:"id"`
	Order        int                    `json:"order"`
	Name         string                 `json:"name"`
	Description  string                 `json:"description"`
	ActionType   ActionType             `json:"action_type"`
	Input        map[string]interface{} `json:"input"`
	Dependencies []string               `json:"dependencies,omitempty"` // Step IDs that must complete first
	Status       StepStatus             `json:"status"`
	Output       map[string]interface{} `json:"output,omitempty"`
	Error        string                 `json:"error,omitempty"`
	StartedAt    *time.Time             `json:"started_at,omitempty"`
	CompletedAt  *time.Time             `json:"completed_at,omitempty"`
	RetryCount   int                    `json:"retry_count"`
}

// StepStatus represents the status of a plan step
type StepStatus string

const (
	StepPending    StepStatus = "pending"
	StepInProgress StepStatus = "in_progress"
	StepCompleted  StepStatus = "completed"
	StepFailed     StepStatus = "failed"
	StepSkipped    StepStatus = "skipped"
)

// ExecutedAction tracks an action that was executed
type ExecutedAction struct {
	ID         string                 `json:"id"`
	StepID     string                 `json:"step_id"`
	ActionType ActionType             `json:"action_type"`
	Input      map[string]interface{} `json:"input"`
	Output     map[string]interface{} `json:"output,omitempty"`
	Success    bool                   `json:"success"`
	Error      string                 `json:"error,omitempty"`
	Duration   time.Duration          `json:"duration"`
	ExecutedAt time.Time              `json:"executed_at"`
}

// Artifact represents something produced by the agent
type Artifact struct {
	ID        string    `json:"id"`
	Type      string    `json:"type"` // file, log, report, deployment
	Name      string    `json:"name"`
	Path      string    `json:"path,omitempty"`
	Content   string    `json:"content,omitempty"`
	Size      int64     `json:"size"`
	CreatedAt time.Time `json:"created_at"`
}

// LogEntry is a structured log message
type LogEntry struct {
	ID        string    `json:"id"`
	Level     LogLevel  `json:"level"`
	Message   string    `json:"message"`
	StepID    string    `json:"step_id,omitempty"`
	Data      any       `json:"data,omitempty"`
	Timestamp time.Time `json:"timestamp"`
}

// LogLevel defines log severity
type LogLevel string

const (
	LogDebug   LogLevel = "debug"
	LogInfo    LogLevel = "info"
	LogWarning LogLevel = "warning"
	LogError   LogLevel = "error"
	LogSuccess LogLevel = "success"
)

// WSUpdate is sent to clients via WebSocket
type WSUpdate struct {
	Type      string    `json:"type"`
	TaskID    string    `json:"task_id"`
	Timestamp time.Time `json:"timestamp"`
	Data      any       `json:"data"`
}

// Update types for WebSocket
const (
	UpdateStateChange   = "state_change"
	UpdateProgress      = "progress"
	UpdateLog           = "log"
	UpdateStepStarted   = "step_started"
	UpdateStepCompleted = "step_completed"
	UpdateStepFailed    = "step_failed"
	UpdateFileCreated   = "file_created"
	UpdateFileModified  = "file_modified"
	UpdateCommandOutput = "command_output"
	UpdateAIResponse    = "ai_response"
	UpdateValidation    = "validation"
	UpdateCompleted     = "completed"
	UpdateError         = "error"
)

// AutonomousAgent is the main agent controller
type AutonomousAgent struct {
	tasks       map[string]*AutonomousTask
	subscribers map[string][]chan *WSUpdate
	planner     *Planner
	executor    *Executor
	validator   *Validator
	mu          sync.RWMutex
	ctx         context.Context
	cancel      context.CancelFunc
}

// AIProvider interface for AI operations
type AIProvider interface {
	Generate(ctx context.Context, prompt string, opts AIOptions) (string, error)
	Analyze(ctx context.Context, content string, instruction string, opts AIOptions) (string, error)
}

// AIOptions for AI calls
type AIOptions struct {
	MaxTokens    int
	Temperature  float64
	SystemPrompt string
}

// NewAutonomousAgent creates a new autonomous agent
func NewAutonomousAgent(aiProvider AIProvider, workDir string) *AutonomousAgent {
	ctx, cancel := context.WithCancel(context.Background())

	agent := &AutonomousAgent{
		tasks:       make(map[string]*AutonomousTask),
		subscribers: make(map[string][]chan *WSUpdate),
		ctx:         ctx,
		cancel:      cancel,
	}

	// Initialize sub-components
	agent.planner = NewPlanner(aiProvider)
	agent.executor = NewExecutor(aiProvider, workDir)
	agent.validator = NewValidator(aiProvider)

	log.Println("Autonomous Agent initialized")
	return agent
}

// StartTask creates and starts a new autonomous task
func (a *AutonomousAgent) StartTask(userID uint, projectID *uint, description string) (*AutonomousTask, error) {
	taskID := uuid.New().String()
	now := time.Now()

	task := &AutonomousTask{
		ID:          taskID,
		UserID:      userID,
		ProjectID:   projectID,
		Description: description,
		State:       StateIdle,
		Progress:    0,
		Logs:        make([]LogEntry, 0),
		Actions:     make([]*ExecutedAction, 0),
		Artifacts:   make([]Artifact, 0),
		Metadata:    make(map[string]interface{}),
		CreatedAt:   now,
		MaxRetries:  3,
	}

	a.mu.Lock()
	a.tasks[taskID] = task
	a.mu.Unlock()

	// Start the task execution in background
	go a.runTask(task)

	log.Printf("Started autonomous task %s for user %d: %s", taskID, userID, truncate(description, 50))
	return task, nil
}

// runTask is the main execution loop for a task
func (a *AutonomousAgent) runTask(task *AutonomousTask) {
	defer func() {
		if r := recover(); r != nil {
			a.setTaskState(task, StateFailed)
			a.addLog(task, LogError, fmt.Sprintf("Agent panic: %v", r), "")
		}
	}()

	now := time.Now()
	task.mu.Lock()
	task.StartedAt = &now
	task.mu.Unlock()

	// Main state machine loop
	for {
		select {
		case <-a.ctx.Done():
			a.setTaskState(task, StateCancelled)
			return
		default:
		}

		task.mu.RLock()
		currentState := task.State
		task.mu.RUnlock()

		switch currentState {
		case StateIdle:
			a.setTaskState(task, StatePlanning)

		case StatePlanning:
			if err := a.planningPhase(task); err != nil {
				a.handleError(task, err)
				continue
			}
			a.setTaskState(task, StateExecuting)

		case StateExecuting:
			if err := a.executingPhase(task); err != nil {
				a.handleError(task, err)
				continue
			}
			a.setTaskState(task, StateValidating)

		case StateValidating:
			if err := a.validatingPhase(task); err != nil {
				a.handleError(task, err)
				continue
			}
			a.setTaskState(task, StateCompleted)

		case StatePaused:
			// Wait until resumed
			time.Sleep(100 * time.Millisecond)

		case StateCompleted:
			a.completeTask(task, nil)
			return

		case StateFailed:
			a.completeTask(task, fmt.Errorf(task.Error))
			return

		case StateCancelled:
			a.completeTask(task, fmt.Errorf("task cancelled"))
			return
		}
	}
}

// planningPhase decomposes the task into an execution plan
func (a *AutonomousAgent) planningPhase(task *AutonomousTask) error {
	a.addLog(task, LogInfo, "Starting planning phase - analyzing requirements", "")
	a.updateProgress(task, 5)

	ctx, cancel := context.WithTimeout(a.ctx, 2*time.Minute)
	defer cancel()

	plan, err := a.planner.CreatePlan(ctx, task.Description)
	if err != nil {
		return fmt.Errorf("planning failed: %w", err)
	}

	plan.TaskID = task.ID

	task.mu.Lock()
	task.Plan = plan
	task.mu.Unlock()

	a.addLog(task, LogSuccess, fmt.Sprintf("Plan created with %d steps", len(plan.Steps)), "")
	a.updateProgress(task, 15)

	// Broadcast plan to subscribers
	a.broadcast(task.ID, &WSUpdate{
		Type:      "plan_created",
		TaskID:    task.ID,
		Timestamp: time.Now(),
		Data:      plan,
	})

	return nil
}

// executingPhase executes all steps in the plan
func (a *AutonomousAgent) executingPhase(task *AutonomousTask) error {
	task.mu.RLock()
	plan := task.Plan
	task.mu.RUnlock()

	if plan == nil || len(plan.Steps) == 0 {
		return fmt.Errorf("no execution plan available")
	}

	totalSteps := len(plan.Steps)
	progressPerStep := 70 / totalSteps // 70% of progress for execution

	for i, step := range plan.Steps {
		// Check if task is still running
		task.mu.RLock()
		state := task.State
		task.mu.RUnlock()

		if state != StateExecuting {
			return nil // Task paused or cancelled
		}

		// Check dependencies
		if !a.areDependenciesMet(plan, step) {
			a.addLog(task, LogWarning, fmt.Sprintf("Waiting for dependencies of step %s", step.Name), step.ID)
			continue
		}

		a.addLog(task, LogInfo, fmt.Sprintf("Executing step %d/%d: %s", i+1, totalSteps, step.Name), step.ID)
		a.broadcastStepStarted(task, step)

		// Execute the step with retry loop
		result, err := a.executeStepWithRetry(task, step)
		if err != nil {
			step.Status = StepFailed
			step.Error = err.Error()
			a.broadcastStepFailed(task, step, err)

			// Check if we should continue or fail
			if !a.canContinueAfterFailure(step) {
				return fmt.Errorf("critical step %s failed: %w", step.Name, err)
			}
		} else {
			step.Status = StepCompleted
			now := time.Now()
			step.CompletedAt = &now
			step.Output = result
			a.broadcastStepCompleted(task, step)
		}

		// Update progress
		baseProgress := 15 // After planning
		a.updateProgress(task, baseProgress+(i+1)*progressPerStep)
	}

	a.addLog(task, LogSuccess, "Execution phase completed", "")
	return nil
}

// executeStepWithRetry executes a step with retry logic
func (a *AutonomousAgent) executeStepWithRetry(task *AutonomousTask, step *PlanStep) (map[string]interface{}, error) {
	var lastErr error

	for attempt := 0; attempt <= 2; attempt++ { // Max 3 attempts
		if attempt > 0 {
			a.addLog(task, LogWarning, fmt.Sprintf("Retrying step %s (attempt %d)", step.Name, attempt+1), step.ID)
			time.Sleep(time.Duration(attempt) * time.Second) // Backoff
		}

		step.Status = StepInProgress
		now := time.Now()
		step.StartedAt = &now

		ctx, cancel := context.WithTimeout(a.ctx, 5*time.Minute)
		result, err := a.executor.ExecuteStep(ctx, step, task)
		cancel()

		if err == nil {
			// Track the executed action
			action := &ExecutedAction{
				ID:         uuid.New().String(),
				StepID:     step.ID,
				ActionType: step.ActionType,
				Input:      step.Input,
				Output:     result,
				Success:    true,
				Duration:   time.Since(now),
				ExecutedAt: now,
			}
			task.mu.Lock()
			task.Actions = append(task.Actions, action)
			task.mu.Unlock()

			return result, nil
		}

		lastErr = err
		step.RetryCount++

		// Let the validator analyze the error and suggest fixes
		ctx2, cancel2 := context.WithTimeout(a.ctx, 30*time.Second)
		analysis := a.validator.AnalyzeError(ctx2, err.Error(), step)
		cancel2()

		if analysis != "" {
			a.addLog(task, LogInfo, fmt.Sprintf("Error analysis: %s", analysis), step.ID)
			// Apply suggested fixes to step input if possible
			a.applySuggestedFixes(step, analysis)
		}
	}

	return nil, fmt.Errorf("step failed after 3 attempts: %w", lastErr)
}

// validatingPhase validates the output and fixes issues
func (a *AutonomousAgent) validatingPhase(task *AutonomousTask) error {
	a.addLog(task, LogInfo, "Starting validation phase", "")
	a.updateProgress(task, 90)

	ctx, cancel := context.WithTimeout(a.ctx, 2*time.Minute)
	defer cancel()

	// Get all artifacts/files created
	task.mu.RLock()
	artifacts := task.Artifacts
	plan := task.Plan
	task.mu.RUnlock()

	// Validate the generated output
	result, err := a.validator.ValidateOutput(ctx, plan, artifacts)
	if err != nil {
		return fmt.Errorf("validation failed: %w", err)
	}

	// Broadcast validation result
	a.broadcast(task.ID, &WSUpdate{
		Type:      UpdateValidation,
		TaskID:    task.ID,
		Timestamp: time.Now(),
		Data:      result,
	})

	if !result.Valid {
		// Attempt self-correction
		if task.RetryCount < task.MaxRetries {
			task.mu.Lock()
			task.RetryCount++
			task.mu.Unlock()

			a.addLog(task, LogWarning, fmt.Sprintf("Validation failed, attempting self-correction (attempt %d)", task.RetryCount), "")

			// Apply fixes based on validation feedback
			if err := a.applySelfCorrection(task, result); err != nil {
				return fmt.Errorf("self-correction failed: %w", err)
			}

			// Re-execute failed steps
			a.setTaskState(task, StateExecuting)
			return nil
		}
		return fmt.Errorf("validation failed: %s", result.Summary)
	}

	a.addLog(task, LogSuccess, "Validation passed", "")
	a.updateProgress(task, 100)
	return nil
}

// handleError handles errors during task execution
func (a *AutonomousAgent) handleError(task *AutonomousTask, err error) {
	a.addLog(task, LogError, err.Error(), "")

	task.mu.Lock()
	task.RetryCount++
	retryCount := task.RetryCount
	maxRetries := task.MaxRetries
	task.mu.Unlock()

	if retryCount > maxRetries {
		task.mu.Lock()
		task.Error = fmt.Sprintf("Task failed after %d retries: %s", retryCount, err.Error())
		task.mu.Unlock()
		a.setTaskState(task, StateFailed)
	} else {
		a.addLog(task, LogWarning, fmt.Sprintf("Retrying task (attempt %d/%d)", retryCount, maxRetries), "")
		// Reset to planning to try a different approach
		a.setTaskState(task, StatePlanning)
	}
}

// completeTask finalizes the task
func (a *AutonomousAgent) completeTask(task *AutonomousTask, err error) {
	now := time.Now()
	task.mu.Lock()
	task.CompletedAt = &now
	if err != nil {
		task.Error = err.Error()
	}
	task.mu.Unlock()

	// Broadcast completion
	a.broadcast(task.ID, &WSUpdate{
		Type:      UpdateCompleted,
		TaskID:    task.ID,
		Timestamp: now,
		Data: map[string]interface{}{
			"state":         task.State,
			"progress":      task.Progress,
			"error":         task.Error,
			"artifacts":     len(task.Artifacts),
			"total_actions": len(task.Actions),
		},
	})

	log.Printf("Task %s completed with state: %s", task.ID, task.State)
}

// setTaskState updates the task state
func (a *AutonomousAgent) setTaskState(task *AutonomousTask, state AgentState) {
	task.mu.Lock()
	oldState := task.State
	task.State = state
	task.mu.Unlock()

	a.broadcast(task.ID, &WSUpdate{
		Type:      UpdateStateChange,
		TaskID:    task.ID,
		Timestamp: time.Now(),
		Data: map[string]interface{}{
			"old_state": string(oldState),
			"new_state": string(state),
		},
	})

	log.Printf("Task %s state: %s -> %s", task.ID, oldState, state)
}

// updateProgress updates the task progress
func (a *AutonomousAgent) updateProgress(task *AutonomousTask, progress int) {
	task.mu.Lock()
	task.Progress = progress
	task.mu.Unlock()

	a.broadcast(task.ID, &WSUpdate{
		Type:      UpdateProgress,
		TaskID:    task.ID,
		Timestamp: time.Now(),
		Data:      progress,
	})
}

// addLog adds a log entry
func (a *AutonomousAgent) addLog(task *AutonomousTask, level LogLevel, message string, stepID string) {
	entry := LogEntry{
		ID:        uuid.New().String(),
		Level:     level,
		Message:   message,
		StepID:    stepID,
		Timestamp: time.Now(),
	}

	task.mu.Lock()
	task.Logs = append(task.Logs, entry)
	task.mu.Unlock()

	a.broadcast(task.ID, &WSUpdate{
		Type:      UpdateLog,
		TaskID:    task.ID,
		Timestamp: entry.Timestamp,
		Data:      entry,
	})

	// Also log to server logs
	log.Printf("[%s] Task %s: %s", level, task.ID[:8], message)
}

// Helper methods

func (a *AutonomousAgent) areDependenciesMet(plan *ExecutionPlan, step *PlanStep) bool {
	if len(step.Dependencies) == 0 {
		return true
	}

	for _, depID := range step.Dependencies {
		for _, s := range plan.Steps {
			if s.ID == depID && s.Status != StepCompleted {
				return false
			}
		}
	}
	return true
}

func (a *AutonomousAgent) canContinueAfterFailure(step *PlanStep) bool {
	// Critical steps that cannot be skipped
	criticalActions := map[ActionType]bool{
		ActionCreateFile: false, // Can skip if file creation fails
		ActionModifyFile: false,
		ActionRunCommand: true, // Must succeed
		ActionRunTests:   false, // Can skip tests
		ActionInstallDeps: true, // Must succeed
	}

	if critical, ok := criticalActions[step.ActionType]; ok {
		return !critical
	}
	return true
}

func (a *AutonomousAgent) applySuggestedFixes(step *PlanStep, analysis string) {
	// Parse the analysis and modify step input accordingly
	// This is a simplified implementation
	if step.Input == nil {
		step.Input = make(map[string]interface{})
	}
	step.Input["previous_error_analysis"] = analysis
}

func (a *AutonomousAgent) applySelfCorrection(task *AutonomousTask, result *ValidationResult) error {
	// Reset failed steps to pending
	task.mu.Lock()
	if task.Plan != nil {
		for _, step := range task.Plan.Steps {
			if step.Status == StepFailed {
				step.Status = StepPending
				step.Error = ""
				step.RetryCount = 0
				// Add validation feedback to input
				if step.Input == nil {
					step.Input = make(map[string]interface{})
				}
				step.Input["validation_feedback"] = result.Issues
			}
		}
	}
	task.mu.Unlock()

	a.addLog(task, LogInfo, "Applied self-correction based on validation feedback", "")
	return nil
}

func (a *AutonomousAgent) broadcastStepStarted(task *AutonomousTask, step *PlanStep) {
	a.broadcast(task.ID, &WSUpdate{
		Type:      UpdateStepStarted,
		TaskID:    task.ID,
		Timestamp: time.Now(),
		Data: map[string]interface{}{
			"step_id":     step.ID,
			"step_name":   step.Name,
			"action_type": step.ActionType,
		},
	})
}

func (a *AutonomousAgent) broadcastStepCompleted(task *AutonomousTask, step *PlanStep) {
	a.broadcast(task.ID, &WSUpdate{
		Type:      UpdateStepCompleted,
		TaskID:    task.ID,
		Timestamp: time.Now(),
		Data: map[string]interface{}{
			"step_id":   step.ID,
			"step_name": step.Name,
			"output":    step.Output,
		},
	})
}

func (a *AutonomousAgent) broadcastStepFailed(task *AutonomousTask, step *PlanStep, err error) {
	a.broadcast(task.ID, &WSUpdate{
		Type:      UpdateStepFailed,
		TaskID:    task.ID,
		Timestamp: time.Now(),
		Data: map[string]interface{}{
			"step_id":   step.ID,
			"step_name": step.Name,
			"error":     err.Error(),
		},
	})
}

// Public API methods

// GetTask retrieves a task by ID
func (a *AutonomousAgent) GetTask(taskID string) (*AutonomousTask, error) {
	a.mu.RLock()
	defer a.mu.RUnlock()

	task, exists := a.tasks[taskID]
	if !exists {
		return nil, fmt.Errorf("task %s not found", taskID)
	}
	return task, nil
}

// GetTaskStatus returns the current status of a task
func (a *AutonomousAgent) GetTaskStatus(taskID string) (map[string]interface{}, error) {
	task, err := a.GetTask(taskID)
	if err != nil {
		return nil, err
	}

	task.mu.RLock()
	defer task.mu.RUnlock()

	return map[string]interface{}{
		"id":           task.ID,
		"state":        task.State,
		"progress":     task.Progress,
		"description":  task.Description,
		"logs_count":   len(task.Logs),
		"actions_count": len(task.Actions),
		"artifacts_count": len(task.Artifacts),
		"error":        task.Error,
		"created_at":   task.CreatedAt,
		"started_at":   task.StartedAt,
		"completed_at": task.CompletedAt,
	}, nil
}

// GetTaskLogs returns the logs for a task
func (a *AutonomousAgent) GetTaskLogs(taskID string, limit int) ([]LogEntry, error) {
	task, err := a.GetTask(taskID)
	if err != nil {
		return nil, err
	}

	task.mu.RLock()
	defer task.mu.RUnlock()

	logs := task.Logs
	if limit > 0 && len(logs) > limit {
		logs = logs[len(logs)-limit:]
	}
	return logs, nil
}

// StopTask stops a running task
func (a *AutonomousAgent) StopTask(taskID string) error {
	task, err := a.GetTask(taskID)
	if err != nil {
		return err
	}

	task.mu.Lock()
	if task.State == StateCompleted || task.State == StateFailed || task.State == StateCancelled {
		task.mu.Unlock()
		return fmt.Errorf("task already in terminal state: %s", task.State)
	}
	task.mu.Unlock()

	a.setTaskState(task, StateCancelled)
	a.addLog(task, LogInfo, "Task stopped by user", "")
	return nil
}

// PauseTask pauses a running task
func (a *AutonomousAgent) PauseTask(taskID string) error {
	task, err := a.GetTask(taskID)
	if err != nil {
		return err
	}

	task.mu.RLock()
	state := task.State
	task.mu.RUnlock()

	if state != StateExecuting && state != StateValidating {
		return fmt.Errorf("can only pause executing or validating tasks")
	}

	a.setTaskState(task, StatePaused)
	a.addLog(task, LogInfo, "Task paused by user", "")
	return nil
}

// ResumeTask resumes a paused task
func (a *AutonomousAgent) ResumeTask(taskID string) error {
	task, err := a.GetTask(taskID)
	if err != nil {
		return err
	}

	task.mu.RLock()
	state := task.State
	task.mu.RUnlock()

	if state != StatePaused {
		return fmt.Errorf("can only resume paused tasks")
	}

	a.setTaskState(task, StateExecuting)
	a.addLog(task, LogInfo, "Task resumed by user", "")
	return nil
}

// Subscribe adds a subscriber for task updates
func (a *AutonomousAgent) Subscribe(taskID string, ch chan *WSUpdate) {
	a.mu.Lock()
	defer a.mu.Unlock()

	if a.subscribers[taskID] == nil {
		a.subscribers[taskID] = make([]chan *WSUpdate, 0)
	}
	a.subscribers[taskID] = append(a.subscribers[taskID], ch)
}

// Unsubscribe removes a subscriber
func (a *AutonomousAgent) Unsubscribe(taskID string, ch chan *WSUpdate) {
	a.mu.Lock()
	defer a.mu.Unlock()

	subs := a.subscribers[taskID]
	for i, sub := range subs {
		if sub == ch {
			a.subscribers[taskID] = append(subs[:i], subs[i+1:]...)
			break
		}
	}
}

// broadcast sends an update to all subscribers
func (a *AutonomousAgent) broadcast(taskID string, update *WSUpdate) {
	a.mu.RLock()
	subs := a.subscribers[taskID]
	a.mu.RUnlock()

	for _, ch := range subs {
		select {
		case ch <- update:
		default:
			// Channel full, skip
		}
	}
}

// Shutdown gracefully shuts down the agent
func (a *AutonomousAgent) Shutdown() {
	a.cancel()
	log.Println("Autonomous Agent shut down")
}

// AddArtifact adds an artifact to a task
func (a *AutonomousAgent) AddArtifact(task *AutonomousTask, artifact Artifact) {
	artifact.ID = uuid.New().String()
	artifact.CreatedAt = time.Now()

	task.mu.Lock()
	task.Artifacts = append(task.Artifacts, artifact)
	task.mu.Unlock()

	a.broadcast(task.ID, &WSUpdate{
		Type:      UpdateFileCreated,
		TaskID:    task.ID,
		Timestamp: artifact.CreatedAt,
		Data:      artifact,
	})
}

func truncate(s string, maxLen int) string {
	if len(s) <= maxLen {
		return s
	}
	return s[:maxLen] + "..."
}
